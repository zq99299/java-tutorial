(window.webpackJsonp=window.webpackJsonp||[]).push([[347],{758:function(t,e,v){"use strict";v.r(e);var a=v(27),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"继承总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#继承总结"}},[t._v("#")]),t._v(" 继承总结")]),t._v(" "),v("p",[t._v("除了 Object 类，一个类只有一个直接的超类。一个类从它的所有超类继承字段和方法，无论是直接的还是间接的。子类可以覆盖继承的方法，也可以隐藏它继承的字段或方法。（请注意，隐藏字段通常是不好的编程习惯。）")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/java/iandi/override.html"}},[t._v("覆盖和隐藏方法")]),t._v(" 部分中的表格 显示了在超类中声明与方法具有相同签名的方法的效果。")],1),t._v(" "),v("p",[t._v("Object 类是类层次结构的顶部。所有的类都是这个类的后代，并继承它的方法。从 Object 继承的有用的方法包括 "),v("code",[t._v("toString()")]),t._v("、"),v("code",[t._v("equals()")]),t._v("、"),v("code",[t._v("clone()")]),t._v(" 和  "),v("code",[t._v("getClass()")]),t._v("。")]),t._v(" "),v("p",[t._v("您可以通过在类的声明中使用 final 关键字来防止类被子类化。同样，可以通过将方法声明为 final 方法来防止方法被子类重写。")]),t._v(" "),v("p",[t._v("抽象类只能被分类; 它不能被实例化。抽象类可以包含抽象方法 - 已声明但未实现的方法。然后子类提供抽象方法的实现。")])])}),[],!1,null,null,null);e.default=n.exports}}]);