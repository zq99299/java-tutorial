(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{603:function(a,t,s){"use strict";s.r(t);var e=s(27),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"内存一致性错误"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存一致性错误"}},[a._v("#")]),a._v(" 内存一致性错误")]),a._v(" "),s("p",[a._v("当不同的线程对于相同数据不一致时，会发生 "),s("strong",[a._v("内存一致性错误")]),a._v("。内存一致性错误的原因很复杂，\n超出了本教程的范围。幸运的是，程序员不需要详细了解这些原因。所有需要的是避免这种情况的策略。")]),a._v(" "),s("p",[a._v("避免内存一致性错误的关键在于理解之前的关系。这种关系只是保证一个特定语句的内存写入对另一个特定语句是可见的。\n要看到这一点，请考虑以下示例。假设一个简单的 int 字段被定义和初始化：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("该"),s("code",[a._v("counter")]),a._v("字段在两个线程 A 和 B 之间共享。假设线程 A 递增 "),s("code",[a._v("counter")]),a._v("：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("counter"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("然后不久之后，线程 B 打印出来 "),s("code",[a._v("counter")]),a._v("：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("counter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("如果两个语句在同一个线程中被执行，那么假定打印出来的值将为“1”是安全的。但是如果两个语句在单独的线程中执行，\n则打印输出的值可能为“0”，因为不能保证线程 A 的更改 "),s("code",[a._v("counter")]),a._v(" 对于线程 B 是可见的，除非程序员已经建立了这些两个声明")]),a._v(" "),s("p",[a._v("有几个操作创建发生之前(happens-before)的关系。其中一个是同步，我们将在以下部分中看到。")]),a._v(" "),s("p",[a._v("我们已经看到了两个创建发生关系的动作:")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("当一个语句被调用 Thread.start 时，每个与该语句发生关系的语句也与新线程执行的每个语句都有一个发生关系。导致新线程创建的代码的效果对于新线程是可见的。")])]),a._v(" "),s("li",[s("p",[a._v("当线程终止并导致 Thread.join 另一个线程返回时，由终止的线程执行的所有语句与成功连接之后的所有语句都有一个发生关系。线程中的代码的效果现在对执行连接的线程是可见的。")])])]),a._v(" "),s("p",[a._v("对于这一系列的动作建立 happens-before 关系，指的汇总页 "),s("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility",target:"_blank",rel:"noopener noreferrer"}},[a._v("java.util.concurrent包"),s("OutboundLink")],1)]),a._v(" "),s("p",[a._v("这里的两个操作描述我第一个没有看懂。翻译太蛋疼了。\n第二个的 Thread.join，也是相当于让线程顺序执行了。")])])}),[],!1,null,null,null);t.default=n.exports}}]);