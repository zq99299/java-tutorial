(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{505:function(t,a,s){"use strict";s.r(a);var r=s(27),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"api-设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#api-设计"}},[t._v("#")]),t._v(" API 设计")]),t._v(" "),s("p",[t._v("在这个简短但重要的部分中，您将学习一些简单的指南，使您的 API 能够遵循这些指南的所有其他的 API 无缝协作。\n本质上这些规则告诉你怎么成为一个优秀的开发？")]),t._v(" "),s("h2",{attrs:{id:"参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[t._v("#")]),t._v(" 参数")]),t._v(" "),s("p",[t._v("定义输入参数的时候尽量定义为接口类型。切勿使用实现，因为这违背了基于接口的集合框架。")]),t._v(" "),s("p",[t._v("此外，你应该总是使用有意义的最小特定类型，例如：如果一个 Collection 能做的事情，不需要 List 或则 Set。\n这并不是说你不应该输入一个 List 或则 Set。如果方法取决于这些接口的属性，这样做是正确的。")]),t._v(" "),s("h2",{attrs:{id:"返回值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#返回值"}},[t._v("#")]),t._v(" 返回值")]),t._v(" "),s("p",[t._v("返回值与输入参数往往相反。最好返回 具体的实现，如 SortedMap，那么就不要返回一个 Map 接口类型。")]),t._v(" "),s("h2",{attrs:{id:"传统-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传统-api"}},[t._v("#")]),t._v(" 传统 API")]),t._v(" "),s("p",[t._v("目前有很多 API 定义自己的临时集合类型。虽然这是不幸的，这是一个事实，因为在 Java 平台的前两个主要版本中没有集合框架。\n假设你拥有这些 API 之一; 这里是你可以做的。")]),t._v(" "),s("p",[t._v("如果能使用平滑过度的函数进行过度操作。那么可以更新为这种方式，\n如果不能，那么定义一个适配器类，它包装遗留的集合对象之一，允许它作为一个标准的集合")]),t._v(" "),s("p",[t._v("如果可能，使用符合输入准则的调用来更新 API，以接收标准的接口对象。\n如果不可能，可以为遗留的提供一个构造函数或静态工厂，它接收一个标准接口对象，并返回包含相同元素的旧的集合。\n这两种方法都运行用户将任意集合传递到您的 API 中。")])])}),[],!1,null,null,null);a.default=e.exports}}]);