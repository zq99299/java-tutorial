(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{616:function(t,v,_){"use strict";_.r(v);var n=_(27),s=Object(n.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[t._v("#")]),t._v(" 同步")]),t._v(" "),_("p",[t._v("线程主要通过共享访问域和引用相同的对象进行通信。这种通信形式是非常有效的，但是有两种错误的可能：\n线程 "),_("strong",[t._v("干扰")]),t._v(" 和 "),_("strong",[t._v("内存一致性错误")]),t._v("。 防止这些错误所需的工具是 "),_("strong",[t._v("同步")])]),t._v(" "),_("p",[t._v("本节包括以下主题：")]),t._v(" "),_("ul",[_("li",[t._v("线程干扰 ： 描述当多个线程访问共享数据时如何引入错误")]),t._v(" "),_("li",[t._v("内存一致性错误 ：描述由共享内存视图不一致的错误")]),t._v(" "),_("li",[t._v("同步方法 ： 描述了可以有效防止线程干扰和内存一致性错误的简单方案")]),t._v(" "),_("li",[t._v("隐式锁和同步 ：描述了更通用的同步方案，并描述了如何基于隐式锁的同步")]),t._v(" "),_("li",[t._v("原子访问 ：谈论的是不能被其他线程干扰的思路")])])])}),[],!1,null,null,null);v.default=s.exports}}]);