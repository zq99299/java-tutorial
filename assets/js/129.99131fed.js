(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{582:function(e,v,_){"use strict";_.r(v);var a=_(27),t=Object(a.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"并发集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发集合"}},[e._v("#")]),e._v(" 并发集合")]),e._v(" "),_("p",[_("code",[e._v("java.util.concurrent")]),e._v(" 软件包包含许多 "),_("code",[e._v("Java Collections Framework")]),e._v(" 的补充。这些都通过提供接口容易分类：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("BlockingQueue")]),e._v(" "),_("p",[e._v("定义当您尝试添加到完整队列或从空队列中检索时，先入先出的数据结构将阻止或超时。")])]),e._v(" "),_("li",[_("p",[e._v("ConcurrentMap")]),e._v(" "),_("p",[e._v("是 "),_("code",[e._v("java.util.Map")]),e._v(" 定义有用的原子操作的子接口。这些操作仅在键存在时才删除或替换键值对，\n或者仅在键不存在时才添加键值对。使这些操作成为原子有助于避免同步。"),_("code",[e._v("ConcurrentMap")]),e._v(" 标准的通用实现是 "),_("code",[e._v("ConcurrentHashMap")]),e._v("，它是一个并行模拟的 "),_("code",[e._v("HashMap")]),e._v("。")])]),e._v(" "),_("li",[_("p",[e._v("ConcurrentNavigableMap")]),e._v(" "),_("p",[e._v("是 "),_("code",[e._v("ConcurrentMap")]),e._v(" 支持近似匹配的子接口。"),_("code",[e._v("ConcurrentNavigableMap")]),e._v(" 标准的通用实现是 "),_("code",[e._v("ConcurrentSkipListMap")]),e._v("，它是一个并行模拟的 "),_("code",[e._v("TreeMap")]),e._v("。")])])]),e._v(" "),_("p",[e._v("所有这些集合都可以通过在将对象添加到集合的操作与后续的访问或删除该对象的操作之间定义一个 "),_("code",[e._v("happens-before")]),e._v(" 的关系来帮助避免内存一致性错误。")]),e._v(" "),_("p",[e._v("!其实看完这里 我并不清楚 ConcurrentMap 为什么就能做到并发？什么场景下能验证？有什么效果？")])])}),[],!1,null,null,null);v.default=t.exports}}]);