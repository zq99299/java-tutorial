# 泛型
::: tip
这是泛型高级篇，基础篇请参考 [这篇](/java/generics/)
:::

J2SE 5.0 中引入了这种期待已久的增强类型系统的功能，它允许 **类型** 或 **方法** 对各种类型的对象进行操作，同时提供了编译时类型的安全性。它为集合框架增加了编译时类型的安全性，并消除了繁重的工作。

- [定义简单泛型](./simple.md)

- [泛型和子类型化](./subtype.md)

- [通配符](./wildcards.md)

- [通用方法](./methods.md)

- [与旧版代码互操作](./legacy.md)

- [细节](./fineprint.md)

- [Class 类作为运行时类型令牌](./literals.md)

- [通配符带来更多乐趣](./morefun.md)

- [将旧版代码转换为使用泛型](./convert.md)

## 介绍

泛型允许您抽象类型。最常见的示例是容器类型。例如集合中的那些类型。下面这个是个典型的用法

```java
List myIntList = new LinkedList(); // 1
myIntList.add(new Integer(0)); // 2
Integer x = (Integer) myIntList.iterator().next(); // 3  
```

第三行的类型转换有点烦人，通常，程序员知道将哪类数据放入特定列表中。编译器只能保证迭代器将返回 Object。为了确保对类型为 Integer 的变量的分配类型是安全的，需要强制转换。

转换带来了混乱，它还引入了运行时错误的可能性，因为程序员可能记错了取出的数据类型。

如果程序员可以实际表达自己的意图，并 **将列表标记为包含特定数据类型**，该怎么办？这是泛型背后的 **核心思想**。下面代码是对上面一段无泛型代码给出的泛型版本

```java
List<Integer> 
    myIntList = new LinkedList<Integer>(); // 1'
myIntList.add(new Integer(0)); // 2'
Integer x = myIntList.iterator().next(); // 3'
```

注意 myIntList 的声明类型，`List <Integer>` 这样的声明我称之为 **带有类型参数的** 通用接口。在创建列表对象的时候，还指定一个类型参数。

还需要注意的是：第 3 行行的强制转换已消失。

现在，你可能认为我们只是将转换转移了，从第三行转移到了第一行中，其实不是，这里有很大的不同。编译器现在可以在 **编译时检查程序的类型** 是否正确。 当声明  `myIntList = new LinkedList<Integer>()` 时，它告诉了我们 myIntList 的信息，该变量无论何时使用都只能添加进 integer 类型的数据，这个编译器对此进行保证。相反的是，如果是强制转换，那么程序员需要在使用到的地方都去做强制转换。

最终效果是提高 **可读性** 和 **健壮性**，尤其是在大型程序中。
